name: Deploy Supabase Infrastructure

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
    paths:
      - 'supabase/**'

env:
  PROJECT_NAME: volve-supabase
  SERVER_PATH: /srv/projects/volve-supabase

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Copy Supabase files to server
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ vars.SERVER_HOST }}
        username: ${{ vars.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        source: "supabase/docker/,supabase/migrations/"
        target: "${{ env.SERVER_PATH }}/"
        strip_components: 1

    - name: Deploy Supabase
      uses: appleboy/ssh-action@v1.0.3
      env:
        # Env-specific values (GitHub Variables)
        API_DOMAIN: ${{ vars.SB_API_DOMAIN }}
        STUDIO_DOMAIN: ${{ vars.SB_STUDIO_DOMAIN }}
        SITE_URL: ${{ vars.SB_SITE_URL }}
        ADDITIONAL_REDIRECT_URLS: ${{ vars.SB_ADDITIONAL_REDIRECT_URLS }}
        API_EXTERNAL_URL: ${{ vars.SB_API_EXTERNAL_URL }}
        SUPABASE_PUBLIC_URL: ${{ vars.SB_SUPABASE_PUBLIC_URL }}
        # Secrets (GitHub Secrets)
        POSTGRES_PASSWORD: ${{ secrets.SB_POSTGRES_PASSWORD }}
        JWT_SECRET: ${{ secrets.SB_JWT_SECRET }}
        ANON_KEY: ${{ secrets.SB_ANON_KEY }}
        SERVICE_ROLE_KEY: ${{ secrets.SB_SERVICE_ROLE_KEY }}
        DASHBOARD_PASSWORD: ${{ secrets.SB_DASHBOARD_PASSWORD }}
        SECRET_KEY_BASE: ${{ secrets.SB_SECRET_KEY_BASE }}
        VAULT_ENC_KEY: ${{ secrets.SB_VAULT_ENC_KEY }}
        PG_META_CRYPTO_KEY: ${{ secrets.SB_PG_META_CRYPTO_KEY }}
        LOGFLARE_PUBLIC_ACCESS_TOKEN: ${{ secrets.SB_LOGFLARE_PUBLIC_TOKEN }}
        LOGFLARE_PRIVATE_ACCESS_TOKEN: ${{ secrets.SB_LOGFLARE_PRIVATE_TOKEN }}
        GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
        GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
      with:
        host: ${{ vars.SERVER_HOST }}
        username: ${{ vars.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        envs: SERVER_PATH,API_DOMAIN,STUDIO_DOMAIN,SITE_URL,ADDITIONAL_REDIRECT_URLS,API_EXTERNAL_URL,SUPABASE_PUBLIC_URL,POSTGRES_PASSWORD,JWT_SECRET,ANON_KEY,SERVICE_ROLE_KEY,DASHBOARD_PASSWORD,SECRET_KEY_BASE,VAULT_ENC_KEY,PG_META_CRYPTO_KEY,LOGFLARE_PUBLIC_ACCESS_TOKEN,LOGFLARE_PRIVATE_ACCESS_TOKEN,GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET
        script: |
          set -e
          cd ${SERVER_PATH}/docker

          # Generate .env from GitHub Vars + Secrets
          cat > .env <<EOF
          # Generated by CI -- do not edit manually
          # Environment-specific
          API_DOMAIN=${API_DOMAIN}
          STUDIO_DOMAIN=${STUDIO_DOMAIN}
          SITE_URL=${SITE_URL}
          ADDITIONAL_REDIRECT_URLS=${ADDITIONAL_REDIRECT_URLS}
          API_EXTERNAL_URL=${API_EXTERNAL_URL}
          SUPABASE_PUBLIC_URL=${SUPABASE_PUBLIC_URL}
          # Secrets
          POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
          JWT_SECRET=${JWT_SECRET}
          ANON_KEY=${ANON_KEY}
          SERVICE_ROLE_KEY=${SERVICE_ROLE_KEY}
          DASHBOARD_PASSWORD=${DASHBOARD_PASSWORD}
          SECRET_KEY_BASE=${SECRET_KEY_BASE}
          VAULT_ENC_KEY=${VAULT_ENC_KEY}
          PG_META_CRYPTO_KEY=${PG_META_CRYPTO_KEY}
          LOGFLARE_PUBLIC_ACCESS_TOKEN=${LOGFLARE_PUBLIC_ACCESS_TOKEN}
          LOGFLARE_PRIVATE_ACCESS_TOKEN=${LOGFLARE_PRIVATE_ACCESS_TOKEN}
          GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
          GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
          EOF

          # Generate Studio basic auth (htpasswd via Docker, doubled $ for Docker Compose)
          # Written separately to avoid $$ expansion issues in heredoc
          STUDIO_RAW=$(docker run --rm httpd:2-alpine htpasswd -nb supabase "${DASHBOARD_PASSWORD}")
          echo "STUDIO_BASIC_AUTH=$STUDIO_RAW" >> .env
          sed -i '/^STUDIO_BASIC_AUTH=/s/\$/\$\$/g' .env

          # Merge .env.config (shared) + .env (env-specific + secrets) -> .env.runtime
          cat .env.config .env > .env.runtime

          echo ".env.runtime = .env.config (shared) + .env (GitHub Vars + Secrets)"

          # Pull latest images and deploy
          docker compose --env-file .env.runtime pull
          docker compose --env-file .env.runtime up -d

          # Wait for services to be healthy
          echo "Waiting for Supabase to be healthy..."
          sleep 20

          # Health check
          if docker ps | grep -q supabase-kong; then
            echo "Supabase API (Kong) is running"
          else
            echo "Deployment failed - Kong not running"
            docker compose --env-file .env.runtime logs kong --tail 20
            exit 1
          fi

          if docker ps | grep -q supabase-db; then
            echo "Database is running"
          else
            echo "Database failed to start"
            docker compose --env-file .env.runtime logs db --tail 20
            exit 1
          fi

    - name: Apply database migrations
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ vars.SERVER_HOST }}
        username: ${{ vars.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        envs: SERVER_PATH
        script: |
          set -e
          cd ${SERVER_PATH}

          # Ensure migration tracking table exists
          docker exec supabase-db psql -U postgres -d postgres -c "
            CREATE TABLE IF NOT EXISTS _migrations (
              filename TEXT PRIMARY KEY,
              applied_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
            );
          "

          # Apply each migration in order (only if not already applied)
          applied=0
          skipped=0
          for f in $(ls migrations/*.sql 2>/dev/null | sort); do
            filename=$(basename "$f")
            already=$(docker exec supabase-db psql -U postgres -d postgres -t -c \
              "SELECT COUNT(*) FROM _migrations WHERE filename = '${filename}';" | tr -d ' ')

            if [ "$already" = "0" ]; then
              echo "Applying: ${filename}"
              docker exec -i supabase-db psql -U postgres -d postgres < "$f"
              docker exec supabase-db psql -U postgres -d postgres -c \
                "INSERT INTO _migrations (filename) VALUES ('${filename}');"
              applied=$((applied + 1))
            else
              echo "Skipping (already applied): ${filename}"
              skipped=$((skipped + 1))
            fi
          done

          echo "Migrations complete: ${applied} applied, ${skipped} skipped"
